"""Tarea Grupal 1 - Extracción Características ECG- Grupo S.B.A.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Julwubb8Y8MVPk1bXVn0XiYgrRImsn6e

# Tarea grupal 1 - Extracción características ECG
<b>Grupo SBA</b>
<br/>
<ul>
<li>Geronimo petrel.</li>
<li>Diego Arturo.</li>
<li>Laura Higuita.</li>
<li>Raúl Rangel.</li>
<li>Eduar Diaz.</li>
<li>Ingrid Sánchez.</li>
</ul>
"""

sp02 = list(range(50, 101))[::-1]
print(sp02)

"""

#Librerias
"""

#!pip install wfdb
import wfdb
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import pandas as pd
from numpy.lib.function_base import append

"""#Obtener señal

1.   Se guarda la señal de physionet de la carpera mitdb del archivo 100 en la variable 'senal' y en la variable 'po' se guarda la informacion basica relacionada con la toma de la señal. Informacion como la frecuencia de muestreo, el tamaño de la señal, la unidades, el número de señales, el nombre de la señal, si cuenta o no con base en el tiempo y tiene comentarios extra.


2.   Se establecio una variable 'ekg' la cual contiene un fragmento de la señal, para facilitar la observacion de la misma.


3.  Se creo una variable 'fs' en donde se extra la informacion de la frecuencia de muestreo de 'po'.
"""

senal,po = wfdb.rdsamp('100', pn_dir='mitdb', channels=[0])
                       
ekg=senal[:1000]

fs=po['fs']

T=1/fs
t=np.arange(1,(len(ekg)+1))*T # Genera vector

"""#Remuestreo

Este paso se hace para aumentar el numero de muestras que contiene la señal, para asi facilitar asegurar una buena detección y una buena extracción de características.

1.  Se establecio una nueva frecuencvia de muestreo.
2.  Con relacion a la nueva frecuencia de muestreo se calculo el periodo de muestreo.
3.  Con los datos da la nueva señal establecidos, se hizo un remuestreo de la señal. 
4.  Para poder graficar la señal con relacion a el tiempo, se creo un vector llamado 'tn' el cual es del mismo tamaño de la nueva señal, y a esta se le multiplico por el periodo de muetreo de dicha señal, con el fin de relacionar el vector creado con el tiempo de muestreo de la señal (s).
"""

fs_nu=1170
Tn=1/fs_nu
ecg_n=signal.resample(ekg,int(len(ekg)*fs_nu/fs))
tn=np.arange(0,(len(ecg_n)))*Tn
plt.plot(tn,ecg_n)
plt.grid()
#=============Renombramiento de variables
ekg=ecg_n
t=tn
fs=fs_nu

"""#Filtro

Se adiciona un filtro pasa banda con frecuencia de corte en 2.5 y 45 Hz para eliminar la desviación de la línea base.
"""

y=np.array(ekg)
#Filtro pasa-banda
b, a = signal.butter(N=4, btype='bandpass', Wn=[2.5,45], fs=fs)

yfilt = signal.filtfilt(b, a, y ,axis=0)

plt.xlim(0,max(t))
plt.plot(t,yfilt)
plt.plot(t, ekg)
plt.legend(["Filtrada" , "sin filtrar"])

plt.grid()

"""#Detector de R

Para detectar la onda R primero se establecio una ventana de 350 s, para esto se multiplico 0.350 con la frecuencia de muestreo, para asi dar el valor maximo para la primera ventana. 

1. Para la primera ventana se inicializo una variable 'ko' en 0 y la variable 'k' se puso en valor anteriormente calculado. 
2. Ya con la ventana establecia, en la variable 'senalp' se guardo el fragmento de la señal que se encuentra dentro de los limites de la ventana. 
3. Dentro de este fragmento de la señal se busca el valor maximo y en que posicion se encuentra, con esta posicion se puede relacionar el valor maximo con con su respectiva coordenada en tiempo. 
4. Los valores mencionados se guardan en su respectiva lista (maxiy:valor maximo, maxix:posicion del valor maximo, maxit:coordenada en tiempo del valor maximo) como valores iniciales.
5. Luego de tener los datos iniciales, se creo ciclo en el que valor de la ventana va cambiando sus limites a razon de 0.353 s y para cada ciclo se le aplica el mismo proceso anteriormente descrito, guardando cada valor en su lista correspondiente.
"""

ven=int(0.350*(fs)) # creacion de ventana 
ko=0
nu=0 #contador

k=ven
cont=1 # Permite conocer la frecuencia cardiaca
#============
senalp =yfilt[ko:k] 
pm=float(max(senalp))#maximo valor en y o amplitud
xpm=np.argmax(senalp)#posición del maximo valor en x
tpm=t[xpm] # Permite conocer la posición xpm en el vector tiempo
#plt.plot([tpm],pm,'or')
maxix=[xpm] #vector donde se guardan el punto x en samples de la coordenada del valor maximo
maxit=[tpm] #vector donde se guardan el punto x en segundos de la coordenada del valor maximo
maxiy=[pm]  #vector donde se guardan el punto y en mv de la coordenada del valor maximo
while k<(len(yfilt)):
  nu+=1
  ko+=ven
  k+=ven
  senalp=yfilt[ko:k]
  pm=float(max(senalp))
  xpm=ko+np.argmax(senalp)
  #print(xpm)
  tpm=t[xpm]
  #print(tpm)
  
  if pm > 0.7:
    #print(xpm,pm)
    #plt.plot([tpm],pm,'or')
    maxiy.append(pm)
    maxix.append(xpm)
    maxit.append(tpm)
    cont+=1

fc=cont*(60/(max(t))) 

print(fc)

plt.plot(maxit,maxiy,'ro')
plt.plot(t,yfilt)
plt.xlim(0,max(t))
plt.title('Señal ECG')
plt.xlabel('t/segundos')
plt.ylabel('mV')
plt.grid()

"""#Detector de onda P

Para identificar el pico de la onda P, se generó una ventana ubicada entre el 70% y el 90% de la distancia entre dos ondas R consecutivas, posteriormente, se identificó el valor maximo al interior de esta ventana. Este proceso se repite para cada ciclo de la señal.

1. Se generan tres arreglos en los cuales se identificará la posición y valor de cada pico P.
2. Se inicalizan contadores, en los cuales se identificará la posición de los picos R.
3. Al interior de un ciclo while se determina la ventana, entre el 70% y 90% de la distancia entre los picos R, expresando esta distancia como un numero entero redondeado hacía el valor mas cercano.
4. En la ventana generada se identifica el valor maximo y la posición correspondiente.
5. Se registran los valores identificados y se grafica el punto correspondiente.
"""

picos=[]
pmpmx=[]
tpmpmx=[]
i=0
oi=1
pico1=maxix[i]
pico2=maxix[oi]

while oi<(len(maxix)):
  pico1=maxix[i]
  pico2=maxix[oi]
  i+=1
  oi+=1
  rr=pico2-pico1
  sup=int(round((pico1+0.7*rr),0))
  inf=int(round((pico1+0.9*rr),0))

  rango=yfilt[sup:inf]
  pico=max(rango)
  pmp=sup+np.argmax(rango)
  tpmp=t[pmp]
  #plt.plot(tpmp,pico,'ro')
  
  picos.append(pico)
  pmpmx.append(pmp)
  tpmpmx.append(tpmp)


plt.plot(tpmpmx,picos,'ro')
plt.plot(t,yfilt)

plt.title('Señal ECG')
plt.xlabel('t/segundos')
plt.ylabel('mV')
plt.xlim(0,max(t))
plt.grid()

"""#Detector de Q

Para detectar el Q del complejo QRS primero se inicializa 3 listas que son las que guardaran, el voltaje (qpicos), la posicion en samples de los picos (qpicos) y la posicion en tiempo de los picos (tqpicos), de cada Q encontrada de la señal.

1. Se hizo un ciclo que estuviera corriendo mientras la variable 'pq' sea menor a el tamaño del vector 'maxix' que es donde se ubica cada uno de los puntos maximo de R.
2. Se inicializo una variable 'dq' en 1, siguiente a esto se creo otro ciclo que se mantendra dentro de del bucle mientras que 'dq' sea mayor a 0. Dentro de este ciclo, una variable 'j' se incrementa, hasta que 'dq' sea negativa, cuando esta es negativa se sale del ciclo y se guarda el valor de 'j' cuando se sale del ciclo.
3. Al salirse del ciclo se guerda el valor de 'j' y se le resta a la posicion pq en el que se encuentre el primer ciclo.
"""

pq = 0
qpicos=[]
pqpicos=[]
tqpicos=[]
while pq < len( maxix ):
  dq=1
  j=0
  
  while dq > 0:
    j+=1
    loca= maxix[pq]
    dq=(yfilt[loca-j+4]- yfilt[loca-j-4])/8
    
    #print(dq)
    #print(j)
  
  qpicos.append(yfilt[ maxix[pq]-j])
  pqpicos.append(maxix[pq]-j)
  tqpicos.append(t[maxix[pq]-j])
  #print('--',j)
  #print('-',pq)
  pq+=1
plt.plot(tqpicos,qpicos,'or')
#print(qpicos)
#print(pqpicos)
plt.plot(t,yfilt)
plt.xlim(0,max(t))
plt.grid()

"""#Detector S

Para identificar el pico de la onda s, se generó una ventana ubicada entre el 0% y el 10% de la distancia entre dos ondas R consecutivas, posteriormente, se identificó el valor maximo al interior de esta ventana. Este proceso se repite para cada ciclo de la señal.

1. Se generan tres arreglos en los cuales se identificará la posición y valor de cada pico s.
2. Se inicalizan contadores, en los cuales se identificará la posición de los picos R.
3. Al interior de un ciclo while se determina la ventana, entre el 0% y 10% de la distancia entre los picos R, expresando esta distancia como un numero entero redondeado hacía el valor mas cercano.
4. En la ventana generada se identifica el valor maximo y la posición correspondiente.
5. Se registran los valores identificados en los arreglos y se grafica el punto correspondiente
"""

picos_s=[]
pmpmx_s=[]
tpmpmx_s=[]
si=0
osi=1

while osi < (len(maxix)):
  
  spico1=maxix[si]
  spico2=maxix[osi]
  si+=1
  osi+=1
  srr=spico2-spico1  
  sup_s=int(round(spico1,0))
  inf_s=int(round((spico1+0.1*srr),0))

  #rango_s=yfilt[sup_s:inf_s]
  spico=min(yfilt[sup_s:inf_s])
  spmp=sup_s+np.argmin(yfilt[sup_s:inf_s])
  tspmp=t[spmp]

  picos_s.append(spico)
  pmpmx_s.append(spmp)
  tpmpmx_s.append(tspmp)

  if spico2 == max(maxix) :
    pico_u_s= min(yfilt[spico2:-1])
    xpico_u_s=spico2+np.argmin(yfilt[spico2:-1])
    tpico_u_s=t[xpico_u_s]
    #===================
    picos_s.append(pico_u_s)
    pmpmx_s.append(xpico_u_s)
    tpmpmx_s.append(tpico_u_s)

    #print('vas bien',tsrf) 
    #plt.plot(tpico_u_s,pico_u_s,'ro')

  
plt.plot(tpmpmx_s,picos_s,'ro')
plt.plot(t,yfilt)

plt.title('Señal ECG')
plt.xlabel('t/segundos')
plt.ylabel('mV')
plt.xlim(0,max(t))
plt.grid()

"""#POnset

Para identificar el punto inicial de la onda P identificó el primer valor a la izquierda del pico de P con una amplitud menor a  0.15 veces la amplitud del pico P.
1. Se generan tres arreglos en los cuales se identificará la posición y valor de cada Onset de P.
2. Se genera un ciclo for psegún el cual se hayará el onset para cada pico p
3. Se genera un ciclo while en el cual se evaluan los valores a la izquierda del pico P hasta identificar la posición de aquel que sea igual o menor a 0,15 veces el pico P.
5. Se registran los valores identificados en los arreglos y se grafica el punto correspondiente.
"""

cj=0
posnet=[]
xposnet=[]
tposnet=[]
for pk in pmpmx:
  temp = pk
  while temp >= 0.15*yfilt[pk] :
    cj+=1
    rangoo=yfilt[pk-cj-2:pk-cj+2]
    temp=np.mean(rangoo)
  posnet.append(yfilt[pk - cj])
  xposnet.append(pk - cj)
  tposnet.append(t[pk - cj])

plt.plot(tposnet,posnet,'ro')
plt.plot(t,yfilt)
plt.grid()
plt.xlim(0,max(t))



"""#POffset

Para identificar el punto final de la onda P identificó el primer valor a la derecha del pico de P con una amplitud menor a 0.15 veces la amplitud del pico P.

1. Se generan tres arreglos en los cuales se identificará la posición y valor de cada Onset de P.
2. Se genera un ciclo for psegún el cual se hayará el offset para cada pico p
3. Se genera un ciclo while en el cual se evaluan los valores a la derecha del pico P hasta identificar la posición de aquel que sea igual o menor a 0,15 veces el pico P.
4. Se registran los valores identificados en los arreglos y se grafica el punto correspondiente.
"""

poffset=[]
xpoffset=[]
tpoffset=[]
for pk in pmpmx:
  temp = pk
  while temp >= 0.15*yfilt[pk] :
    cj+=1
    rangoo=yfilt[pk+cj-2:pk+cj+2]
    temp=np.mean(rangoo)
  poffset.append(yfilt[pk + cj])
  tpoffset.append(t[pk + cj])
  xpoffset.append(pk + cj)
plt.plot(tpoffset,poffset,'ro')
plt.plot(t,yfilt)
plt.xlim(0,max(t))
plt.grid()

"""#QOnset

Para identificar el punto inicial de la señal Q, se identifico el primer diferencial positivo entre puntos a la izquierda del pico Q.
1. Se generan dos arreglos en los cuales se identificará la posición y valor de cada Onset de Q.
2. Se genera un ciclo for según el cual se hayará el Onset para cada pico Q, exceptuando el primero.
3. Se genera un ciclo while en el cual se hayará la pendiente entre un punto y el punto ubicado cuatro muestras a la derecha de este, hasta que la pendiente sea positiva.
4. Se registran los valores identificados para lograr la pendiente positiva en los arreglos y se grafica el punto correspondiente
"""

qonset=[]
tqonset=[]
for pkq in pqpicos:
  if pkq!=pqpicos[0]:
    dqq=-1
    jq=0
    while dqq<0:
      jq+=1
      dqq=(yfilt[pkq-jq+2]- yfilt[pkq-jq-2])/4
    qonset.append(yfilt[pkq-jq])
    tqonset.append(t[pkq-jq])
plt.plot(tqonset,qonset,'ro')
plt.plot(t,yfilt)
plt.xlim(0,max(t))
plt.grid()

"""#Extracción

Se identifican caracteristicas adicionales de la onda de ECG, altura de la onda P, ancho de la onda P, segmento PR, area de la onda P, variabilidad de frecuencia cardiaca y alternancia electrica de QR

1. Se generan 6 arreglos en los cuales se almacenaran los valores de las caracteristicas antes descritas, para cada uno de los ciclos.
2. Se genera un ciclo de tal forma que las caracteristicas sean identificadas para cada ciclo de la señal.
3. Se identifica  y anexa al arreglo la altura de P como el valor de cada pico P registrado.
4. Se identifica y anexa al arreglo el ancho de la onda P como la diferencia entre el onset y el offset de la onda P.
5. Se identifica y anexa al arreglo el segmento PR como la distancia entre el offset de P y el Onset de Q.
6. Para el calculo del area de P se hace un aproximado con la suma de riemann
7. Se identifica y anexa la variabilidad de frecuencia cardiaca tomando en cuenta que esta se calcula como 60 sobre la distancia entre dos picos R consecutivos multiplicada por la frecuencia cardiaca.
8. Se identifica la alternancia electrica como la diferencia entre los picos R y Q.
"""

ondapalto=[]
ondapancho=[]
segmentopr=[]
areaondap=[]
HRV=[]
tareaondap=[]
QRelectricalAlternans=[]
areap=[]
u=range(len(pmpmx))
a=0
ar=1
k=0
h=0
for ex in u:
  ondapalto.append(picos[ex])
  ondapancho.append(tpoffset[ex]-tposnet[ex])
  segmentopr.append(tqonset[ex]-tpoffset[ex])
  
  for ig in range(xposnet[ex],xpoffset[ex]):
      
      g=((yfilt[ig]+yfilt[ig+1])/fs)
      h+=g
      
  areap.append(h/2)
  h=0

  HRV.append(round(60/(maxit[ex+1]-maxit[ex])))
  QRelectricalAlternans.append(maxiy[ex]-qpicos[ex])

ondapalto=np.squeeze(ondapalto)
areap=np.squeeze(areap)
QRelectricalAlternans=np.squeeze(QRelectricalAlternans)

"""Se realizo la lectura de las distintas variables de las ondad y se imprimio en una respectiva tabla relizando una comparación de tres ciclos."""

fuf={'Altura onda p(mV)':pd.Series(ondapalto)}
df=pd.DataFrame(fuf)

df['Ancho onda p(s)']=ondapancho
df['Segmento pr(s)']=segmentopr
df['Area onda p']=areap
df['HRV']=HRV
df['Altura QR(mV)']=QRelectricalAlternans

"""#Graficas

Por último se grafican todos los puntos detectados previamente en una sola grafica para facilitar el analisis global y mejor visualización. 
1. En color rojo se grafican los picos de las ondas P, Q, R y S.
2. En color negro se grafican el inicio y final de la onda P, y el inicio de la onda Q.
3. Se le añade titulo, los nombres de ejes y el rango de la gráfica. Adicional se añadio la cuadricula para mejor análisis
"""

plt.plot(t,yfilt)

plt.plot(maxit,maxiy,'ro')

plt.plot(tpmpmx,picos,'r*')
plt.plot(tpmpmx_s,picos_s,'rv')
plt.plot(tqpicos,qpicos,'r^')
#==============================
plt.plot(tqonset,qonset,'k*')
plt.plot(tposnet,posnet,'ko')
plt.plot(tpoffset,poffset,'ko')

#=============================

plt.title('Señal ECG')
plt.xlabel('t/segundos')
plt.ylabel('mV')
plt.xlim(0,max(t))
plt.legend(["señal" ,"R peak","P peak","S peak","Q peak","Q onset"], loc='upper right')
plt.grid()

print(df)

